{
  "hash": "8fa906b10ebf476f65c7121c11cee372",
  "result": {
    "markdown": "---\ntitle: \"Analysis with MIPAnalyzer\"\noutput: html_document\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n## Overview \n`MIPanalyzer` is a tool suite for analyzing Molecular Inversion Probe (MIP) data with functionalitiies that could be extended to other platforms/outputs such as small variant call files (VCFs) or multi-loci amplicon data. However, for the purpose of this tutorial, we will focus on MIP data using the file structure and outputs from the Bailey-Lab and [`MIPTools`](https://github.com/bailey-lab/MIPTools). \n\n<br>\n\nThe `MIPanalyzer` suite has four main arenas of analysis:   \n\n1. Munging/wrangling MIP data    \n2. Calculating genetic distance \n1. Analyzing genetic structure    \n2. Summarizing Drug Resistance Mutations (work in progress)   \n\n\nThe tool is intended to make analysis of MIP data straightforward and standardized. Notably, many of the methods within the package rely on within-sample allele-frequencies to account for complexity of infection/polyclonality.\n\n\n## Data Input\nWe assume that the user has two files: (1) a variant call file following [VCF4 specifications](chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://samtools.github.io/hts-specs/VCFv4.3.pdf) and (2) an amino acid table (TBD).  \n\n\n\n\n## Munging MIP Data\nAs input for `MIPanalyzer`, we will start with a variant call file, abbreviated as a [VCF](chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://samtools.github.io/hts-specs/VCFv4.3.pdf) of the Sanger Barcode from Vietnam. The VCF is converted into a `mipanalyzer` class that is either biallelic or multiallelic depending on the user specification. \n\n::: {.cell result='hide'}\n\n```{.r .cell-code}\n#......................\n# read in the VCF from the main data page \n# and convert to  mipanalyzer_biallelic object\n#......................\ndat_biallelic <- MIPanalyzer::vcf_to_mipanalyzer_biallelic(\"../../data/snp_barcode/sangerBarcode_SNP_INDEL_Pf3D7_ALL_v3.combined.filtered.vqslod6.biallelic_snp.Vietnam.vcf.gz\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nScanning file to determine attributes.\nFile attributes:\n  meta lines: 136\n  header_line: 137\n  variant count: 91\n  column count: 106\n\nMeta line 136 read in.\nAll meta lines processed.\ngt matrix initialized.\nCharacter matrix gt created.\n  Character matrix gt rows: 91\n  Character matrix gt cols: 106\n  skip: 0\n  nrows: 91\n  row_num: 0\n\nProcessed variant: 91\nAll variants processed\n```\n:::\n:::\n\nThe `dat_biallelic` object is a protected MIPanalyzer class (`mipanalyzer_biallelic`) that is tidy and fast container for genomic data. It has slots for sample name, loci (CHROM/POS/ID/REF/ALT/QUAL/FILTER/INFO), coverage (alleleic depth or dp), counts (allelic counts or ad), filter history (upstream manipulations performed on the object), and vcfmeta (the header of the original VCF file). \n\n### Filter \nData can be quickly filtered using a series of commands. Moreover, `MIPanalyzer` incorporates  several data visualization functions that extend the interactiveness of filtering process. Below, I explore how much data will be lost if I filter loci that have at least 10 reads for all samples (minimal coverage is 10 reads with a 0% tolerance for any missing data).  \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_biallelic %>% \n explore_filter_coverage_loci(min_coverage = 10, max_low_coverage = 0)\n```\n\n::: {.cell-output-display}\n![](MIPanalyzer_analysis_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nI then apply this filter as so: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_biallelic <- dat_biallelic %>%\n  filter_coverage_loci(min_coverage = 10, max_low_coverage = 0)\n```\n:::\n\nThere are similar capabilities to filter by sample (`filter_samples`) and by loci (`filter_loci`). Within the `filter_samples` framework, users can exclude samples that have poor coverage cross the genome. Below, I should how these fucntions can be used: filtering samples based on coverage (25 depth for all sites is shown below).\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_biallelic %>% \n explore_filter_coverage_samples(min_coverage = 25, max_low_coverage = 0)\n```\n\n::: {.cell-output-display}\n![](MIPanalyzer_analysis_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n```{.r .cell-code}\ndat_biallelic <- dat_biallelic %>%\n  filter_coverage_samples(min_coverage = 10, max_low_coverage = 0)\n```\n:::\n\n\nSimilarly, loci that have an unexpected amount of sequencing effort (\"jackpotting\") that may be prone to sequencing error can also be excluded with `filter_overcounts`. Finally, users can remove sites that are uninformative (all variants are the same) with `filter_loci_invariant`. This is demonstrated below: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_biallelic <- dat_biallelic %>%\n  filter_loci_invariant()\n```\n:::\n\n\n## Calculating Genetic Distances\nFor this section, we will explore pairwise relatedness through a variety of genetic distance measures. In the first schema, we can consider how allele frequencies are similar between samples using the $d_{ab}$ metric proposed by the MalariaGEN Plasmodium falciparum Community Project in the article \"Genomic epidemiology of artemisinin resistant malaria\", eLIFE (2016) (`get_genomic_distance`). \n\nIn a separate, schema, we can calculate the similarity between two samples based on whether the genetic sequence is identical at given genomic positions, or loci. We can either simply measure the number of sites with identical alleles between two individuals, termed identity by state (IBS), or, we can use statistical models to determine if identical alleles and \"blocks\" of the genome were likely to be inherited from a common ancestor, termed identity by descent (IBD). Separately, we can calculate if within-sample allele frequencies (+/- some degree of tolerance) are identical between two individuals - which is essentially a continuous extension of IBS. The IBS calculations are straightforward and just represent comparisons between samples. IBD calculations require parametric assumptions in order to account for the heritability factor (as part of its definition). The IBD calculator incorporated in MIPanalyzer is based off the classic Mal√©cot definition of IBD and is considered in a maximum-likelihood framework. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# AF based methods \ndab_est <- get_genomic_distance(dat_biallelic, report_progress = FALSE)\n# identity based methods\nmix_est <- get_IB_mixture(dat_biallelic, report_progress = FALSE)\nibd_est <- inbreeding_mle(dat_biallelic, \n                          f = seq(0, 1, l = 5),\n                          report_progress = FALSE)\nibs_est <- get_IBS_distance(dat_biallelic, report_progress = FALSE)\n```\n:::\n\nThe output for each distance calculator is a distance matrix with the upper triangle filled in, with the exception of the IBD estimator that also includes the log-likelihood of each inbreeding level, $f$, considered by the model (specified by user).  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# plot all pairwise distances (make a distance instead of similarity score with 1-x)\np1 <- plot_distance(1 - ibd_est$mle, col_pal = \"magma\") + ggtitle(\"IBD Dist\")\np2 <- plot_distance(1 - mix_est, col_pal = \"inferno\") + ggtitle(\"Mixture Dist\")\np3 <- plot_distance(1 - ibs_est, col_pal = \"plasma\") + ggtitle(\"IBS Dist\")\np4 <- plot_distance(dab_est, col_pal = \"viridis\") + ggtitle(\"Dab Dist\")\n\ncowplot::plot_grid(p1,p2,p3,p4, nrow = 2, ncol = 2)\n```\n\n::: {.cell-output-display}\n![](MIPanalyzer_analysis_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\nAs expected, our samples have much less IBD than IBS. Similarly, the $D_{ab}$ has a wide range of values. However, across all four genomic distances, sample pairs that are highly related are \n\n\n## Analyzing Genetic Structure  \nIn this section, we will perform a principal _component_ analysis and plot the results to assess for structure (as part of an exploratory data analysis exercise).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# calculate within-sample allele frequencies\nwsaf <- get_wsaf(dat_biallelic, )\n# produce pca \npca <- pca_wsaf(wsaf)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_pca(pca, num_components = 3)\n```\n:::\n\n<img src=\"https://github.com/mrc-ide/MIPanalyzer/raw/master/vignettes/PCA_scatter.png\" style=\"width: 80%\">\n\nWe can also look at the amount of variance captured in our principal components as well as which loci are contributing most to the variation. Understanding the amount of variance that is captured in the principal components conveys how much structure is in the data, while understanding which loci are contributing the most variation conveys signals of selection, drift, etc.\n\n::: {.cell}\n\n```{.r .cell-code}\n# plot percentage variance explained\nplot_pca_variance(pca)\n```\n:::\n\n\n<img src=\"https://github.com/mrc-ide/MIPanalyzer/raw/master/vignettes/PCA_variance.png\" style=\"width: 60%\">\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get CHROM in numeric format for each locus\nchrom_numeric <- mapply(function(x) as.numeric(strsplit(x, \"_\")[[1]][2]), dat_biallelic$loci$CHROM)\n\n# plot loading values\nplot_pca_contribution(pca, component = 1, chrom = chrom_numeric, pos = dat_biallelic$loci$POS)\n```\n\n::: {.cell-output-display}\n![](MIPanalyzer_analysis_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nAnother approach to analyzing structure is to assess principal _coordinate_ analysis. While principal component analysis (PCA) is based on linear combinations, principal coordinate analysis (PCoA) is based on minimizing distance based on an internal loss function (also called classical scaling, function back-ended by `ape::pcoa`). The utility of PCoA versus PCA, is that PCoA can take _any_ distance (matrix) that the user specifies and thus can capture genetic structures that may be nonlinear. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# genomic distance from malariagen manuscript as above\ngdist <- get_genomic_distance(dat_biallelic, report_progress = FALSE)\n# perform PCoA\npcoa <- pcoa_genomic_distance(gdist)\n# scatterplot\nplot_pcoa(pcoa, num_components = 3)\n```\n:::\n\n\n<img src=\"https://github.com/mrc-ide/MIPanalyzer/raw/master/vignettes/PCOA_scatter.png\" style=\"width: 80%\">\n\n\n\n\n\n## Summarizing Drug Resistance Mutations (work in progress)\nTo Do (pending file format from Bailey group)\n\n\n## Summary\nIn this tutorial, we explored how to use the `MIPanalyzer` to munge/wrangle MIP data, filter samples, and prepare our MIP data for analysis. We then performed genetic analysis by calculating genetic distances as well as analyzing our data for genetic structure. \n",
    "supporting": [
      "MIPanalyzer_analysis_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}