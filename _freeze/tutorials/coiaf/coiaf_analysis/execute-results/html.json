{
  "hash": "eefe4f97f087c24413606e73243e954a",
  "result": {
    "markdown": "---\ntitle: \"Running `coiaf`\"\noutput: html_document\n---\n\n\n\n\n## Introduction\n\nFor this tutorial, we will be using the `coiaf` package to estimate the complexity of infection (COI) from SNP barcode data. Instructions to install this package may be found [here](coiaf_installation.html).\n\n## The data\n\n`coiaf` expects a matrix of within sample reference allele frequencies (WSAF), as well as an estimate of population level reference allele frequencies (PLAF). The WSAF matrix should have samples in rows and sites in columns. The PLAF should be a vector of length equal to the number of sites. To explore this, we will use simulated SNP barcoding data as described [here](../../website_docs/data_description.html#simulated-1). We will load the data using the `vcfR` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvcf_data <- vcfR::read.vcfR(\n  here::here(\"data/snp_barcode/SpotMalariapfPanel_simData_sanger100.vcf.gz\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nScanning file to determine attributes.\nFile attributes:\n  meta lines: 76\n  header_line: 77\n  variant count: 100\n  column count: 109\n\nMeta line 76 read in.\nAll meta lines processed.\ngt matrix initialized.\nCharacter matrix gt created.\n  Character matrix gt rows: 100\n  Character matrix gt cols: 109\n  skip: 0\n  nrows: 100\n  row_num: 0\n\nProcessed variant: 100\nAll variants processed\n```\n:::\n:::\n\n\nTo calculate within host allele frequencies, we need to extract the depth of coverage and allele counts\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoverage <- t(vcfR::extract.gt(vcf_data, element = \"DP\", as.numeric = TRUE))\ncounts_raw <- t(vcfR::extract.gt(vcf_data, element = \"AD\"))\ncounts <- vcfR::masplit(\n  counts_raw, record = 1, sort = FALSE, decreasing = FALSE\n)\n\n# We then directly calculate the WSAF\nwsaf <- counts / coverage\n\n# and estimate the PLAF with the empirical mean across samples\nplaf <- colMeans(wsaf, na.rm = TRUE)\n```\n:::\n\n\n## Running `coiaf`\n\ncoiaf calcualtes the COI on a sample by sample basis, so we need to break up the WSAF matrix into a list of data frames\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput_data <- purrr::map(seq_len(nrow(wsaf)), function(i) {\n  tibble::tibble(wsmaf = wsaf[i, ], plmaf = plaf) |>\n    tidyr::drop_na()\n})\n```\n:::\n\n\nWe can then run `coiaf` on each sample using `purrr::map_dbl`\n\n\n::: {.cell hash='coiaf_analysis_cache/html/unnamed-chunk-4_e5147c2003cb173a83bd574191f091cc'}\n\n```{.r .cell-code}\nresults <- purrr::map_dbl(\n  input_data, ~ coiaf::optimize_coi(.x, data_type = \"real\")\n)\n\n# We can then combine the results into a data frame with the sample names\nres_df <- data.frame(Patient = rownames(wsaf), COI = results)\n```\n:::\n\n\n## Plotting the results\n\nNow that we have the estimated COI for each sample, we can plot the results. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot(res_df, aes(x = COI)) +\n  geom_histogram() +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))\n```\n\n::: {.cell-output-display}\n![](coiaf_analysis_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n## Uncertainty quantification\n\n`coiaf` also provides a function to estimate the uncertainty in the COI estimate. This function uses a non-parametric bootstrap to estimate the uncertainty in the COI estimate. Note that this function can take a long time to run, so we will only run it on the first 10 samples.\n\n\n::: {.cell hash='coiaf_analysis_cache/html/unnamed-chunk-6_a3781c90bb3b833d3e4350d591feb42f'}\n\n```{.r .cell-code}\n# We can use the same input data as before\nbootstrap_results <- purrr::map(\n  input_data[1:10], ~ coiaf::bootstrap_ci(.x, solution_method = \"continuous\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"All values of t are equal to  1 \\n Cannot calculate confidence intervals\"\n```\n:::\n\n```{.r .cell-code}\n# We can then combine the results into a data frame with the sample names\nbootstrap_df <- data.frame(\n  Patient = rownames(wsaf)[1:10], bootstrap_results |> dplyr::bind_rows()\n)\n```\n:::\n\n\nWe can then plot the results for each sample\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  bootstrap_df,\n  aes(x = Patient, y = coi, ymin = conf.low, ymax = conf.high)\n) +\n  geom_pointrange() +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))\n```\n\n::: {.cell-output-display}\n![](coiaf_analysis_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n## Summary\n\nIn this tutorial, we have shown how to use `coiaf` to estimate the complexity of infection from SNP barcode data. For more information on the package, please see the [package documentation](https://bailey-lab.github.io/coiaf/). ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}