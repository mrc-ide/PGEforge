{
  "hash": "bdebc284d8db27e9110a87f0ee7f573c",
  "result": {
    "markdown": "---\ntitle: \"Using `dcifer` to estimate relatedness from biallelic SNP data\"\noutput: html_document\nauthor: \"Kathryn Murie\"\ndate: \"11 December 2023\"\n---\n\n\n\n\n## The data\n\nBelow we will demonstrate how to use `dcifer` using biallelic Sanger 100-SNP barcode data in .vcf format. We will use data created by simulating 100 polyclonal infections from Bangladesh (n=50) and Ghana (n=50). See the [PGEforge website](https://mrc-ide.github.io/PGEforge/website_docs/data_description.html#simulated-1) for further details.\n\nIn this tutorial we will use `PGEhammer` to convert data from the VCF format to the format required by Dcifer. To install the package run the following command\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install PGEhammer in R:\ninstall.packages('PGEhammer', repos = c('https://plasmogenepi.r-universe.dev', 'https://cloud.r-project.org'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nThe downloaded binary packages are in\n\t/var/folders/wx/rr171mzs0lj0mtflng6dwl7h0000gp/T//Rtmp8DqrQV/downloaded_packages\n```\n:::\n:::\n\n\nNow we can load the packages we will need. \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(here)\nlibrary(dcifer)\nlibrary(vcfR)\nlibrary(kableExtra)\nlibrary(PGEhammer)\n```\n:::\n\n\n## Wrangling the data\n\nDcifer requires input data in long format, the long format represents data with each observation on a separate row. This data can be biallelic or multiallelic. \nIn the following steps, we will convert the Variant Call Format (VCF) data to the required long format using the function `vcf2long` from PGEhammer.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read vcf\nvcf <- read.vcfR(here('data/snp_barcode/SpotMalariapfPanel_simData_sanger100.vcf.gz'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nScanning file to determine attributes.\nFile attributes:\n  meta lines: 76\n  header_line: 77\n  variant count: 100\n  column count: 109\n\nMeta line 76 read in.\nAll meta lines processed.\ngt matrix initialized.\nCharacter matrix gt created.\n  Character matrix gt rows: 100\n  Character matrix gt cols: 109\n  skip: 0\n  nrows: 100\n  row_num: 0\n\nProcessed variant: 100\nAll variants processed\n```\n:::\n\n```{.r .cell-code}\n# Convert to long format \ndf <- vcf2long(vcf)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nConverting from vcf to long format...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nReformatting complete.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in vcf2long(vcf): Your vcf is not all bi-allelic. Make sure to double\ncheck if this is not expected.\n```\n:::\n\n```{.r .cell-code}\nhead(df) |>\n  kable() |>\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\", \"condensed\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover table-condensed\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> sample_id </th>\n   <th style=\"text-align:left;\"> locus </th>\n   <th style=\"text-align:left;\"> allele </th>\n   <th style=\"text-align:right;\"> read_count </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Ghana-45 </td>\n   <td style=\"text-align:left;\"> Pf3D7_01_v3_145515 </td>\n   <td style=\"text-align:left;\"> allele-1 </td>\n   <td style=\"text-align:right;\"> 889 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Ghana-45 </td>\n   <td style=\"text-align:left;\"> Pf3D7_01_v3_145515 </td>\n   <td style=\"text-align:left;\"> allele-2 </td>\n   <td style=\"text-align:right;\"> 7354 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Ghana-45 </td>\n   <td style=\"text-align:left;\"> Pf3D7_01_v3_179347 </td>\n   <td style=\"text-align:left;\"> allele-1 </td>\n   <td style=\"text-align:right;\"> 1061 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Ghana-45 </td>\n   <td style=\"text-align:left;\"> Pf3D7_01_v3_179347 </td>\n   <td style=\"text-align:left;\"> allele-2 </td>\n   <td style=\"text-align:right;\"> 9661 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Ghana-45 </td>\n   <td style=\"text-align:left;\"> Pf3D7_01_v3_180554 </td>\n   <td style=\"text-align:left;\"> allele-1 </td>\n   <td style=\"text-align:right;\"> 9564 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Ghana-45 </td>\n   <td style=\"text-align:left;\"> Pf3D7_01_v3_180554 </td>\n   <td style=\"text-align:left;\"> allele-2 </td>\n   <td style=\"text-align:right;\"> 5 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Calculate COI and allele frequencies\n\nBefore we calculate IBD we first need to calculate COI. Below we use the function `getCOI` that Dcifer provides which uses naive estimation, but you could use another tool for this.\n\n::: {.cell}\n\n```{.r .cell-code}\nlrank <- 2\ncoi   <- getCOI(dsmp, lrank = lrank)\n```\n:::\n\n\nThe last thing we need to do before calculating IBD is to add in allele frequencies. Again we use a function within Dcifer for this, `calcAfreq`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nafreq <- calcAfreq(dsmp, coi, tol = 1e-5) \nstr(afreq, list.len = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 87\n $ t1  : Named num [1:5] 0.4239 0.2808 0.1116 0.0422 0.1415\n  ..- attr(*, \"names\")= chr [1:5] \"D10--D6--FCR3--V1-S.0\" \"HB3.0\" \"t1.0\" \"t1.1\" ...\n $ t10 : Named num [1:4] 0.8539 0.00942 0.00951 0.12717\n  ..- attr(*, \"names\")= chr [1:4] \"D10--D6--HB3.0\" \"t10.0\" \"t10.2\" \"U659.0\"\n  [list output truncated]\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndres0 <- ibdDat(dsmp, coi, afreq, pval = TRUE, confint = TRUE, rnull = 0, \n                alpha = 0.05, nr = 1e3)   \n```\n:::\n\n\n# Visualising the Data \n\nHere we use `plotRel` to visualise the data, comparing samples on the axes. Significantly related samples are outlined in red. \n\n::: {.cell}\n\n```{.r .cell-code}\nalpha <- 0.05                          # significance level                    \ndmat <- dres0[, , \"estimate\"]\n# create symmetric matrix\ndmat[upper.tri(dmat)] <- t(dmat)[upper.tri(t(dmat))]  \n#  determine significant, reverse columns for upper triangle\nisig <- which(dres0[, , \"p_value\"] <= alpha, arr.ind = TRUE)[, 2:1] \nplotRel(dmat, isig = isig, draw_diag = TRUE, lwd_diag = 0.5, idlab = TRUE, )\n```\n\n::: {.cell-output-display}\n![](dcifer_analysis_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n## Summary\n\nIn summary, we have used Dcifer to estimate COI and allele frequencies before estimating IBD. Dcifer has extensive [documentation](https://eppicenter.github.io/dcifer), including more details on [other functionality available](https://eppicenter.github.io/dcifer/reference/index.html) within the tool and a [tutorial](https://eppicenter.github.io/dcifer/articles/vigArticle.html) using microhaplotype data.",
    "supporting": [
      "dcifer_analysis_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}