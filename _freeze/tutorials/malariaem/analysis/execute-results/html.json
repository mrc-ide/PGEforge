{
  "hash": "01f58d8a06b69d17b4ace899547a2e5b",
  "result": {
    "markdown": "---\ntitle: \"Analyze data with `malaria.em`\"\noutput: html_document\n---\n\n\n\n\n## Background\n\nFor this tutorial, we will be using the `malaria.em` package to phase and estimate the population-level frequency of multi-locus genotypes using simulated microhaplotype data from Mozambique (more info on the data here data can be found [here](https://mrc-ide.github.io/PGEforge/website_docs/data_mhaps.html#simulated-data)). See the [installation instructions](https://mrc-ide.github.io/PGEforge/tutorials/malariaem/installation.html) if you haven't installed `malaria.em` before.\n\n### The data\nLoad data from [amplicon/mozSim_MAD4HATTERDiversitySubPanel.tab.txt.gz](https://github.com/mrc-ide/PGEforge/tree/main/data/amplicon/mozSim_MAD4HATTERDiversitySubPanel.tab.txt.gz))\n\n::: {.cell}\n\n```{.r .cell-code}\nmhap <- import(here('data/amplicon/mozSim_MAD4HATTERDiversitySubPanel.tab.txt.gz'))\n```\n:::\n\n\nThe simulated dataset includes 100 samples sampled from Mozambique and for a newer diversity panel called MAD^4HatTeR with 50 targets selected for their diversity. The data.frame contains four columns: `sample`, `target`, `target_popUID`, and `readCnt`. We will not exploit read count so we will remove this variable. \n\n::: {.cell}\n\n```{.r .cell-code}\nmhap <- mhap |> select(-readCnt)\n```\n:::\n\n\nWe have a total of 50 diversity targets (`target`) and a total of 574 unique alleles (`target_popUID`) across all targets. \n\nFor this tutorial, we will focus on only 5 targets for illustrative purposes, but also because `malaria.em` can be computationally intensive if there are many targets (i.e. haplotype combinations) and COI is high. We subset 5 targets at random below. \n\n::: {.cell}\n\n```{.r .cell-code}\n# targets_to_subset <- mhap |> distinct(target) |> slice_sample(n=5) |> pull(target)\n\ntargets_to_subset <- c(\"Pf05-0213059-0213219\", \"Pf05-0350840-0351019\", \"Pf08-0102308-0102500\", \"Pf11-1295135-1295311\", \"Pf13-1465925-1466124\")\ntargets_to_subset\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Pf05-0213059-0213219\" \"Pf05-0350840-0351019\" \"Pf08-0102308-0102500\"\n[4] \"Pf11-1295135-1295311\" \"Pf13-1465925-1466124\"\n```\n:::\n:::\n\n\nFor the subset of 5 targets, there are a total of 55 unique alleles (`target_popUID`) across all targets. \n\n### Getting input ready for `malaria.em`\n\n`malaria.em` expects a matrix with samples as rows and columns as the target loci. The observed alleles in each locus must be separated by a space, and the order of columns corresponds to the order of loci on a chromosome. \n\nTherefore, we need to convert our data to wide format, filter to only the 5 targets and then save as a matrix.\n\n::: {.cell}\n\n```{.r .cell-code}\nmhap_matrix <- mhap |>\n  group_by(sample, target) |>\n  pivot_wider(names_from = target,\n              values_from = target_popUID,\n              values_fn = ~ paste(unique(.), collapse = \" \")) |>\n  column_to_rownames(var = \"sample\") |> \n  select(any_of(targets_to_subset)) |> # this is optional, but we are doing this so that malaria.em runs relatively quickly.\n  as.matrix()\n```\n:::\n\n\n## Analysis\n\n### Running `malaria.em`\n\nWe are now ready to run the `malaria.em::malaria_em()` function. The function requires the following arguments:\n\n- `geno` or input matrix: each column represents the alleles observed in each of the target loci. \n- `sizes` or coi: an integer or vector of possible COI in the observed data. If only using a fixed integer, this should include the maximum COI observed in the data, otherwise if the COI is a vector of length > 1, the estimation will assume a zero-truncated Poisson distribution on COI. \n- `locus.label` or allele names: a vector of allele names\n\n\nWe check the COI of our observed data.\n\n::: {.cell}\n\n```{.r .cell-code}\nmhap |> \n  filter(target %in% targets_to_subset) |>\n  count(sample, target, name = \"n_alleles\") |>       \n  summarise(max_alleles_per_sample = max(n_alleles), .by = sample) |> \n  summarise(min_coi = min(max_alleles_per_sample),\n            max_coi = max(max_alleles_per_sample)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  min_coi max_coi\n1       1       3\n```\n:::\n\n```{.r .cell-code}\ncoi_range <- mhap |> \n  filter(target %in% targets_to_subset) |> \n  count(sample, target, name = \"n_alleles\") |>       \n  summarise(max_alleles_per_sample = max(n_alleles), .by = sample) |> \n  summarise(min_coi = min(max_alleles_per_sample),\n            max_coi = max(max_alleles_per_sample)) |>\n  with(seq(min_coi, max_coi))\n```\n:::\n\n*Note that we have chosen a combination of 5 targets that have a max observed COI of 3 in the samples. This will take some trial and error for your own datasets given the haplotype combinatorics - but we found that when COI>3 for this simulated dataset was where `malaria.em` began to struggle.*\n\nNow let's run `malaria.em()`:\n\n::: {.cell hash='analysis_cache/html/unnamed-chunk-6_1ff4f366bcb189fd9138c34b6fb20635'}\n\n```{.r .cell-code}\ntic.clear()\ntic.clearlog()\n# recording how long this takes to run\ntic(\"running malaria.em()\")               \n\noutput <- malaria.em::malaria.em(geno = mhap_matrix,\n                                 sizes = coi_range,\n                                 locus.label = colnames(mhap_matrix))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe program is slow, please be patient......\nfinding possible haplotype combinations... \nhaploset size =  1 \nhaploset size =  2 \nhaploset size =  3 \nStarting em......\nDone......\n```\n:::\n\n```{.r .cell-code}\ntoc(log = TRUE)     \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nrunning malaria.em(): 1499.852 sec elapsed\n```\n:::\n\n```{.r .cell-code}\n# extract elapsed seconds\nlog_entry <- tic.log(format = FALSE)[[1]]\nelapsed_secs <- log_entry$toc - log_entry$tic\n\nmessage(sprintf(\"malaria.em took %.3f seconds\", elapsed_secs))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nmalaria.em took 1499.852 seconds\n```\n:::\n\n```{.r .cell-code}\nmalariaem_run_time <- elapsed_secs\n```\n:::\n\nThis took 25 minutes to run. \n\n### Taking a look at `malaria.em` output\n\nThe output object is a list of 10 objects. The documentation indicates they are as follows: \n\n- `haplo.prob.tab` matrix of unique haplotypes, MLEs of estimated haplotype probabilities, and their standard errors.\n\n- `haplotype`\tmatrix of unique haplotypes. Each row represents a unique haplotype, and the number of columns is the number of loci.\n\n- `haplo.prob` vector of MLEs of haplotype probabilities. The ith element of hap.prob corresponds to the ith row of haplotype.\n\n- `haplo.prob.std`\tstandard error of the estimated haplotype frequencies.\n\n- `lambda` estimated Poisson parameter.\n\n- `NumofInfection` estimated number of infections.\n\n- `haplo.sets`\tList of all possible haplotype combinations and their posterior probability per subject. The first column named ids is a vector for row index of subjects after expanding to all possible haplotype combinations for each subject. If ids=i, then i is the ith row of geno. If the ith subject has n possible haplotype combinations that correspond to their marker genotype, then i is repeated n times. The value in the second column is the row numbers of the unique haplotypes in the returned haplotype matrix.\n\n- `n.haplo.set` vector of maximum number of haplotype combinations per subject that are consistent with their marker data in the matrix geno. The length of n.haplo.set = nrow(geno).\n\n- `pred.haplo.set` Predicted haplotype combination that is consistent with their marker data for each subject. The values in pred.haplo.set are the row numbers of the unique haplotypes in the returned haplotype matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutput |> glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 10\n $ haplo.prob.tab: chr [1:1320, 1:7] \"Pf05-0213059-0213219.00\" \"Pf05-0213059-0213219.00\" \"Pf05-0213059-0213219.00\" \"Pf05-0213059-0213219.00\" ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : chr [1:1320] \"1\" \"2\" \"3\" \"4\" ...\n  .. ..$ : chr [1:7] \"Pf05-0213059-0213219\" \"Pf05-0350840-0351019\" \"Pf08-0102308-0102500\" \"Pf11-1295135-1295311\" ...\n $ haplotype     : chr [1:1320, 1:5] \"Pf05-0213059-0213219.00\" \"Pf05-0213059-0213219.00\" \"Pf05-0213059-0213219.00\" \"Pf05-0213059-0213219.00\" ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:5] \"Pf05-0213059-0213219\" \"Pf05-0350840-0351019\" \"Pf08-0102308-0102500\" \"Pf11-1295135-1295311\" ...\n $ haplo.prob    : num [1:1320] 7.72e-08 9.64e-03 1.08e-04 4.80e-07 8.76e-03 ...\n $ haplo.prob.std: num [1:1320] 0.00166 0.00959 0.002 0.00115 0.00349 ...\n $ lambda        : num 1.04\n $ lambda.std    : num 0.00163\n $ NumofInfection: num 1.61\n $ haplo.sets    :'data.frame':\t22934 obs. of  3 variables:\n  ..$ ids      : int [1:22934] 1 1 1 2 2 2 3 3 3 3 ...\n  ..$ haplo.set: chr [1:22934] \"1135\" \"1135 1135\" \"1135 1135 1135\" \"1301\" ...\n  ..$ post.p   : num [1:22934] 9.94e-01 6.42e-03 2.77e-05 9.97e-01 3.23e-03 ...\n $ n.haplo.set   : int [1:100] 3 3 1328 3 10 3 3 44 3 232 ...\n $ pred.haplo.set: chr [1:100] \"1135\" \"1301\" \"697 690\" \"475\" ...\n - attr(*, \"class\")= chr \"malaria.em\"\n```\n:::\n:::\n\n\n### Summarizing population-level genotype frequencies\nWe can now take a look at the estimated population-level multi-locus genotype (MLG) frequencies. We will reshape the `output$haplo.prob.tab` to create an object in long-format for plotting. \n\nEvery unique multi-locus genotype is composed of a set of alleles at *K* target loci. In this tutorial each MLG has 5 target loci. The outputs from `malaria.em` keep track of MLG ID indices (row index, `gt_id`) that we now need to link back to our original target and target_popUIDs labels before pivotting to long-format.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Population-level multilocus genotype frequency estimate + standard error \ngt_freq_summary <- output$haplo.prob.tab |> \n  as.data.frame() |>\n  # get our gt_id from our row index\n  rowid_to_column(\"gt_id\") |>\n  pivot_longer(cols = -c(\"gt_id\", \"hap.prob\", \"hap.prob.std\"), \n               names_to = \"target\", \n               values_to = \"target_popUID\") |>\n  select (gt_id, \n          target,\n          target_popUID,\n          freq = hap.prob, \n          freq_se = hap.prob.std)\n```\n:::\n\n\nOur new `gt_freq_summary` data frame looks like this, where we now have our `gt_id` linked to the `target` loci names and alleles `target_popUID` that comprise each `gt_id`. \n\n::: {.cell}\n\n```{.r .cell-code}\ngt_freq_summary |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  gt_id target               target_popUID           freq                freq_se\n  <int> <chr>                <chr>                   <chr>               <chr>  \n1     1 Pf05-0213059-0213219 Pf05-0213059-0213219.00 7.72392295022328e-… 0.0016…\n2     1 Pf05-0350840-0351019 Pf05-0350840-0351019.00 7.72392295022328e-… 0.0016…\n3     1 Pf08-0102308-0102500 Pf08-0102308-0102500.0  7.72392295022328e-… 0.0016…\n4     1 Pf11-1295135-1295311 Pf11-1295135-1295311.00 7.72392295022328e-… 0.0016…\n5     1 Pf13-1465925-1466124 Pf13-1465925-1466124.00 7.72392295022328e-… 0.0016…\n6     2 Pf05-0213059-0213219 Pf05-0213059-0213219.00 0.00963620874391006 0.0095…\n```\n:::\n:::\n\n\nBecause there are many MLGs with low frequencies, we will filter for any with a frequency > 0.001. \n\n::: {.cell}\n\n```{.r .cell-code}\ngt_freq_summary %>% \n  mutate(gt_id = factor(gt_id),\n         freq = as.numeric(freq),\n         freq_se = as.numeric(freq_se),\n         gt_id = fct_reorder(gt_id, freq)) %>%\n  # Arbitrary filtering for easier viz\n  filter(freq > 0.001) %>%\n  ggplot(aes(x = gt_id, y = freq)) +\n    geom_point() +\n    geom_errorbar(aes(ymin = freq - freq_se,\n                      ymax = freq + freq_se)) +\n    labs(x = \"Multi-locus genotype ID\",\n         y = \"Population-level frequency estimate + SE\") +\n    theme_bw() +\n    theme(axis.text.x = element_text(angle = 90, hjust = 1))\n```\n\n::: {.cell-output-display}\n![](analysis_files/figure-html/unnamed-chunk-10-1.png){width=1152}\n:::\n:::\n\n\n### Summarizing sample-level phased genotypes\nA major advantage of `malaria.em` is that we can obtain phased multi-locus genotypes with corresponding posterior probability estimates. In this tutorial we do not explore the full posterior probabilities of each multi-locus genotype, but rather we focus on the 'predicted' multi-locus genotype and corresponding posterior probability estimate in the `output$pred.haplo.set`. Note that a `haplo.set` as referred to by `malaria.em` can be either one multi-locus genotype (a set of alleles observed at *K* loci) if COI is 1  or a set of multi-locus genotypes if COI > 1 (set with >1 multi-locus genotypes). So we have multiple layers embedded within our outputs that need to be linked together. \n\nThe outputs from `malaria.em` keep track of subject or sample ID indices (row index, `ids`) and MLG IDs (`gt_id`) that we now need to link back to our actual sample names, as well as our original target and target_popUIDs labels (remember each `gt_id` is actually composed of *K* targets).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the most probable MLG per sample\nhaplo_pred <- as.data.frame(output$pred.haplo.set) |> rename(haplo.set = `output$pred.haplo.set`) |> rowid_to_column(\"ids\")\n# get the posterior probabilites for all MLGs\nhaplo_pred_prob <- as.data.frame(output$haplo.sets) \n# get the sample names corresponding to row indices in matrix (this is what malaria.em uses in the output objects)\nsample_name <- mhap_matrix |> as.data.frame() |> rownames_to_column(\"sample\") |> distinct(sample) |> rowid_to_column(\"ids\") \n\n# create gt_phase_summary object, start from haplo_pred\ngt_phase_summary <- haplo_pred |>\n  as.data.frame() |> \n  # get the posterior probability for each MLG set (haplo.set)\n  left_join(haplo_pred_prob, \n            by = join_by(ids, haplo.set)) |>\n  # get sample name\n  left_join(sample_name, join_by(ids)) |>\n  # rearrange and rename \n  select(sample,\n         haplo.set,\n         posterior_est = post.p) |> \n  # separate into one row per MLG\n  separate_rows(haplo.set, sep = \" \") |> \n  rename(gt_id = haplo.set) |>\n  mutate(gt_id = as.integer(gt_id)) |>\n  # now get gt info, including the target and target_popUID that make up a gt_id\n  left_join(gt_freq_summary, join_by(gt_id), relationship = \"many-to-many\") |>\n  select(sample, target, target_popUID, gt_id, posterior_est) |> \n  # create a variable to identify unique phased mlgs within a sample\n  mutate(phase_id = dense_rank(gt_id), .by = sample)\n```\n:::\n\n\nOur new `gt_phase_summary` data frame looks like this:\n\n::: {.cell}\n\n```{.r .cell-code}\ngt_phase_summary |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  sample  target               target_popUID        gt_id posterior_est phase_id\n  <chr>   <chr>                <chr>                <int>         <dbl>    <int>\n1 Moz-001 Pf05-0213059-0213219 Pf05-0213059-021321…  1135         0.994        1\n2 Moz-001 Pf05-0350840-0351019 Pf05-0350840-035101…  1135         0.994        1\n3 Moz-001 Pf08-0102308-0102500 Pf08-0102308-010250…  1135         0.994        1\n4 Moz-001 Pf11-1295135-1295311 Pf11-1295135-129531…  1135         0.994        1\n5 Moz-001 Pf13-1465925-1466124 Pf13-1465925-146612…  1135         0.994        1\n6 Moz-002 Pf05-0213059-0213219 Pf05-0213059-021321…  1301         0.997        1\n```\n:::\n:::\n\n\nFor plotting we create a `custom_palette()` function that can generate unique colors for each combination of target/target_popUID. We save our `pal` object for plotting.\n\n::: {.cell}\n\n```{.r .cell-code}\ncustom_palette <- function(gt_phase_summary){\n  gt_phase_summary |> \n  distinct(target, target_popUID) |> \n  group_by(target) |> \n  # generate unique color for each target/target_popUIS combo, ggsci is a good option as it has a lot of colors (>30 I think)\n  mutate(color = paletteer::paletteer_d(\"ggsci::default_igv\")[1:n()]) |>\n  ungroup() |> \n  # generate unique key for target_id/target_popUIS combo\n  mutate(key = paste(target, target_popUID, sep = \"::\")) |>\n  # get palette vector\n  with(set_names(color, key))\n}\n\npal <- custom_palette(gt_phase_summary)\n```\n:::\n\n\nWe also use the fill to show the posterior probability estimate of the phased multi-locus haplotype, with lighter/more transparent indicating low probability/confidence. \n\n::: {.cell}\n\n```{.r .cell-code}\ngt_phase_summary |> \n  # create key variable\n  mutate(key = paste(target, target_popUID, sep = \"::\"),\n         # this is an arbitrary labeling for now for easier viz\n         target_id_short = dense_rank(target)\n         ) |>\n  ggplot(aes(x = target_id_short, y = factor(gt_id), fill = key)) +\n    geom_tile(aes(alpha = posterior_est), color = \"grey10\") +\n    scale_fill_manual(values = pal) +\n    facet_wrap(~sample, scales = \"free\") +\n    labs(x = \"Target ID\",\n         y = \"Phased genotype ID\",\n         alpha = \"Posterior \\nprobability \\nestimate\",\n         caption = \"Target IDs:\\n 1 = Pf05-0213059-0213219 \\n 2 = Pf05-0350840-0351019 \\n 3 = Pf08-0102308-0102500 \\n 4 = Pf11-1295135-1295311 \\n 5 = Pf13-1465925-1466124\") +\n    guides(fill = F) +\n    theme_bw() \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The `<scale>` argument of `guides()` cannot be `FALSE`. Use \"none\" instead as\nof ggplot2 3.3.4.\n```\n:::\n\n::: {.cell-output-display}\n![](analysis_files/figure-html/unnamed-chunk-14-1.png){width=1248}\n:::\n:::\n\n\n## Summary\n\nIn this tutorial, we have shown how to run `malaria.em` on simulated microhaplotype data to estimate multi-locus genotype frequencies and compute the maximum likelihood estimation for phased multi-locus genotypes within samples. The `malaria.em` algorithm is very powerful and provides one of the few available tools for phasing multi-locus data and estimating multi-locus genotype frequencies. However, there are several limitations to consider: \n\n- The program can be very slow and is not computationally efficient when the haplotype combinatorics are too complex (eg high COIs, many loci, many samples). Depending on the complexity of your data, the program may not be suitable. \n- The 'predicted' multi-locus haplotypes are probabilistic phased estimates, so communciating the probability estimates is very important for downstream interpretation!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}