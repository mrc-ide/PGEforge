---
title: "isoRelate tutorial for generating Identity-by-decent networks: vcf to network"
author: Kirsty McCann
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(kableExtra)
library(isoRelate)
library(SeqArray)
library(igraph)
```

## Useful tutorial examples

If you are starting from ped and map files, there is a very clear and comprehensive tutorial `introduction.Rmd` created by isoRelate's author, Lyndal Henden, that uses isoRelates in built data to work through the package functions.
https://github.com/bahlolab/isoRelate/blob/master/vignettes/introduction.Rmd

The data used in the vignette tutorial is a _Plasmodium falciparum_ dataset from Papua New Guinea (PNG), generated by the MalariaGEN Consortium (https://www.malariagen.net/projects/pf3k). When you load isoRelate you are able to trial the functions and visualise how your data should be formated.

## New tutorial

This tutorial focuses on data from the processed vcf stage and works through the process to generate appropriate map and ped files from vcf data within R. IsoRelate only uses the pedmap format and needs to be formatted correctly to generate appropriate relatedness calculations.


## The data

The data in this tutorial is the SNP barcoding SpotMalariapfPanel_simData_sanger100.vcf.gz (https://mrc-ide.github.io/PGEforge/data/). Please refer to the [main Data tab](https://mrc-ide.github.io/PGEforge/website_docs/data_description.html) for further details on this dataset.

Currently, indels will cause errors in the pedmap file format. During the vcf filtering steps, opt to remove indels and only keep SNPs.

## Key Functions

Function | Description
------------------ | --------------------------------------------------
getGenotypes | reformat the genotypes in the PED/MAP file and perform data filtering
getIBDparameters | estimate IBD parameters between pairs of isolates
getIBDsegments | detect IBD segments between pairs of isolates
getIBDposterior | calculate the posterior probability of IBD sharing per isolate pair
getIBDsummary | print a summary of the IBD segments detected
getIBDmatrix | create a binary matrix of IBD/non-IBD for all SNP and pairs
getIBDproportions | calculate the proportion of pairs IBD at each SNP
getIBDiR | calculate the significance of excess IBD sharing at each SNP
getIBDiclusters | create a network of clusters of isolates who are IBD over an **interval**
getIBDpclusters | create a network of clusters of isolates who share a certain **proportion** of genome IBD
plotIBDsegments | plot the detected IBD segments across the genome
plotIBDproportions | plot the proportion of pairs IBD across the genome
plotIBDiR | plot the significance of excess IBD sharing across the genome
plotIBDclusters | plot the network of IBD isolates 

## Step 1

Process your vcf files into pedmap format.

The input for isoRelate is unpahsed genotype data for SNPs in PLINK PED and MAP format (http://www.cog-genomics.org/plink2). You can choose to process your vcf files using PLINK prior to using this workflow. However a R script has been developed to improve the speed of this process.


```{r vcf_file_to_pedmap_format}
showfile.gds(closeall = TRUE)

# vcf_to_gds(input, output)
vcf_to_gds("pf7.PNG.radish.vcf.gz", "pf7.PNG.radish.gds")  

# gds_to_pedmap(input_gds, output_map, output_ped)
gds_to_pedmap("pf7.PNG.radish.gds", "my_map.map", "my_ped.ped")

```

Once you have generated the ped and map files, the next step is to generate ibd metrics.

## Step 2

```{r reformat}
# load your ped and map files 
pedmap <- list()
pedmap[[1]] <- read.delim("ped_file.ped", 
                          stringsAsFactors = FALSE, header=FALSE)
pedmap[[2]] <- read.delim("map_file.map", stringsAsFactors = FALSE,
                          header=FALSE)

# reform genotypes from the pedmap format ready for isorelate
# maf = A numeric value denoting the smallest minor allele frequency allowed in the analysis. The default value is 0.01.
# isolate.max.missing	= A numeric value denoting the maximum proportion of missing data allowed for each isolate. The default value is 0.1.
# snp.max.missing	= A numeric value denoting the maximum proportion of missing data allowed for each SNP. The default value is 0.1.
my_genotypes <- isoRelate::getGenotypes(ped.map = pedmap,
                                        reference.ped.map = NULL,
                                        maf = 0.01,
                                        isolate.max.missing = 0.3,
                                        snp.max.missing = 0.3,
                                        chromosomes = NULL,
                                        input.map.distance = "cM")

# recommended to save these files for later use
readr::write_rds(my_genotypes, "my_genotypes.rds")

# Estimate the model parameters
my_parameters <- getIBDparameters(ped.genotypes = my_genotypes,
                                  number.cores = 8)

# view these files - optional
head(my_parameters)
```

```{r, ibd_segments message = FALSE, eval = TRUE, echo = FALSE}
# recommended to save these files for later use
readr::write_rds(my_parameters, "ibd_parameters.rds")
# my_parameters <- readr::read_rds("ibd_parameters.rds") # can use this command to retrieve your saved file

my_posterior <- getIBDposterior(ped.genotypes = my_genotypes,
                                parameters = my_parameters,
                                error=0.001,
                                number.cores = 8)
# recommended to save these files for later use
readr::write_rds(my_posterior, "ibd_posterior.rds")
# my_posterior <- readr::read_rds("ibd_posterior.rds") # can use this command to retrieve your saved file

# Here we calculate the ibd segments. Minimum snps refers to 
# minimum.snps = An integer value denoting the minimum number of SNPs in an IBD segment for it to be reported. The default value is 20 SNPs.
# minimum.length.bp	= The minimum length of a reported IBD segment. The default value is 50,000 bp.
my_ibd_1 <- getIBDsegments(ped.genotypes = my_genotypes,
                           parameters = my_parameters,
                           minimum.snps = 1,
                           minimum.length.bp = 1,
                           error = 0.001)
# recommended to save these files for later use
readr::write_rds(my_ibd_1, path="ibd_segments_nsnp_1_len_1.rds")
# my_ibd <- readr::read_rds("ibd_segments_nsnp_1_len_1.rds") # can use this command to retrieve your saved file

# recommended to save these files for later use
my_ibd_20 <- getIBDsegments(ped.genotypes = my_genotypes,
                           parameters = my_parameters,
                           minimum.snps = 20,
                           minimum.length.bp = 20,
                           error = 0.001)

```

Depending on the research question, you can obtain IBD segments across varying length of IBD segments and including a threshold of SNPs. Each dataset is likely to be different. There is also the option to make the analysis more strigent by lowering the amount of allowed missing data.

Typically the thresholds are set to use the minimum number of SNPs and length of IBD segments reported in order to reduce false positive IBD calls that are most likely due to population linkage disequilibrium from extremely distant relatedness.

We can get a brief summary of the IBD segments as follows.

```{r, message = FALSE}

# get a summary of IBD segments
getIBDsummary(ped.genotypes = my_genotypes, 
              ibd.segments = my_ibd) 

``` 

## Step 3: Visualising and interpretting IBD Results

There are several ways to visualise and use the IBD results. The follow shows basic visualisations.

```{r, message = FALSE}
my_proportion <- getIBDproportion(ped.genotypes = my_genotypes,
                                  ibd.matrix = my_matrix,
                                  groups = my_groups)

# plot the proportion of pairs IBD
plotIBDproportions(ibd.proportions = my_proportion,
                   interval = NULL,
                   annotation.genes = NULL,
                   annotation.genes.color = NULL,
                   highlight.genes = NULL,
                   highlight.genes.labels = FALSE,
                   highlight.genes.color = NULL,
                   highlight.genes.alpha = 0.1,
                   line.color = NULL,
                   add.rug = FALSE,
                   plot.title = "Proportion of pairs IBD in PNG - with stratification",
                   add.legend = FALSE,
                   facet.label = TRUE,
                   facet.scales = "fixed",
                   subpop.facet = TRUE)
                          
``` 

To identify genomic loci with significant amounts of excess IBD we can apply a transformation to the binary IBD matrix to account for variations in isolate relatedness as well as SNP allele frequencies, then calculate a summary statistic that can be used to assess significance.

```{r, message = FALSE}

# calculate the significance of IBD sharing
my_iR <- getIBDiR(ped.genotypes = my_genotypes, 
                  ibd.matrix = my_matrix, 
                  groups = NULL)

# plot the iR statistics
plotIBDiR(ibd.iR = my_iR, 
          interval = NULL, 
          annotation.genes = NULL,
          annotation.genes.color = NULL,
          highlight.genes = NULL,
          highlight.genes.labels = FALSE,
          highlight.genes.color = NULL,
          highlight.genes.alpha = 0.1,
          point.size = 1,
          point.color = NULL,
          add.rug = FALSE, 
          plot.title = "Significance of IBD sharing", 
          add.legend = FALSE,
          facet.label = TRUE, 
          facet.scales = "fixed")

                          
``` 

A 5% significance threshold would identify regions that have SNPs with -log10 (P-values) > -log10(0.05) as having significant IBD sharing, indicative of positive selection.

Importantly, the function `getIBDiR` can return `NA` values which may occur when there are no IBD pairs or when all pairs are IBD, or when only several isolates are analyzed, among other reasons.

We can investigate the specific isolate pairs that are contributing to the excess IBD sharing on chromosome 7 by creating an IBD network.
Such a network will identify clusters of isolates sharing a common haplotype over this region. We include our example grouping of isolates
when plotting the network.

```{r, message = FALSE}

# generate the isolates who are IBD over the Plasmodium falciparum mdr1 gene
my_i_clusters <- getIBDiclusters(ped.genotypes = my_genotypes, 
                                 ibd.segments = my_ibd_1, 
                                 interval = c("Pf3D7_05_v3", 955955, 963095), 
                                 prop=0, 
                                 hi.clust = FALSE)

str(my_i_clusters)

# plot the network of clusters
plotIBDclusters(ped.genotypes = my_genotypes, 
                clusters = my_i_clusters, 
                groups = NULL, 
                vertex.color = NULL, 
                vertex.frame.color = "white",
                vertex.size = 4, 
                vertex.name = FALSE, 
                edge.color = "gray60", 
                edge.width = 0.8, 
                mark.border = "white",
                mark.col = "gray94", 
                add.legend = TRUE, 
                legend.x = -1.5, 
                legend.y = -0.25, 
                layout = NULL, 
                return.layout = FALSE)
                          
``` 

Each time the function `plotIBDclusters()` is run the vertex layout will differ. 
This is an artifact of the R package used to generate the network, `igraph`.
If the user wishes to keep the network layout the same in multiple subsequent figures then set `return.layout = TRUE` and use the returned layout
in subsequent `plotIBDclusters()` runs with `layout = my_layout`.

We note that the `i.network` is output as the second object in the list  `my_i_clusters`. If the user wishes to perform quantitative analyses using this network, there are many functions in the `i.graph` package to do so. Please see the `i.graph` documentation for more details on this.

We can also explore networks of isolates sharing a large proportion of their genome IBD. 
Such isolates may represent duplicate samples or individuals who have identical infections.


```{r, message = FALSE}

# generate the isolates who share at least than 90% of their genome IBD
my_p_clusters <- getIBDpclusters(ped.genotypes = my_genotypes, 
                                 ibd.segments = my_ibd_1, 
                                 prop=0.9, 
                                 hi.clust = FALSE)

# plot the network of clusters
plotIBDclusters(ped.genotypes = my_genotypes, 
                clusters = my_p_clusters, 
                groups = NULL, 
                vertex.color = NULL, 
                vertex.frame.color = "white",
                vertex.size = 4, 
                vertex.name = FALSE, 
                edge.color = "gray60", 
                edge.width = 0.8, 
                mark.border = "white",
                mark.col = "gray94", 
                add.legend = TRUE, 
                legend.x = -1.5, 
                legend.y = -0.25, 
                layout = NULL, 
                return.layout = FALSE)
                          
``` 

## Summary

IsoRelate is an R package that is able to take variant call data to performm identity by descent (IBD) analysis. IsoRelate can handle multiclonal infections. 

In this tutorial, a function has been developed to process the vcf file to pedmap format for IsoRelate.
