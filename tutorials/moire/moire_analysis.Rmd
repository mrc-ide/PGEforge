---
title: "Running Moire Example"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(kableExtra)
```

## The data

In this analysis we will be using the SNP barcode data from the sanger 100 SNP Plasmodium falciparum barcode [(Chang et al. 2019)]( https://doi.org/10.7554/eLife.43481). 
This was generated by subsetting the WGS data (also described within the [Data section](../../website_docs/data_description.qmd) of this website) and we will be using the data from the DRC. 
See the description in the [Data section](../../website_docs/data_description.qmd) for more details on this dataset.

First, import libraries that we will need. 

```{r, warning=FALSE, message=FALSE, error=FALSE}
library(tidyverse)
library(here)
library(vcfR)
```

Moire requires input data in either long or wide format, which can be loaded using the `load_long_form_data()` or `load_delimited_data()` functions, respectively. The long format represents data with each observation on a separate row, while the wide format uses a separate column for each variable. In the following steps, we will convert the Variant Call Format (VCF) data to the required long format using the function vcf2long from PGEhammer.

```{r vcflong_func}
vcf2long <- function(vcf = NULL) {
  
  # check inputs
  #assert_class(vcf, "vcfR")
  
  # print message to console
  message("Converting from vcf to long format...")
  
  # extract allele counts
  ad <- t(extract.gt(vcf, element = 'AD'))
  
  # make df and into long format
  counts_df <- ad |> 
    as.data.frame() |> 
    rownames_to_column("sample_id") |> 
    pivot_longer(cols = -.data$sample_id, names_to = "locus", values_to = "read_count")
  
  # unnest read_count
  long_df <- counts_df |>
    rowwise() |>
    # split all read count values
    mutate(read_count = list(str_split(.data$read_count, ",")[[1]])) |>
    unnest(cols = .data$read_count) |> 
    group_by(.data$sample_id, .data$locus) |> 
    # create new variable 'allele'
    mutate(allele = paste0("allele-", rep(1:n()))) |> 
    relocate(.data$allele, .before = .data$read_count)
  
  message("Reformatting complete.")
  
  # Check if any loci are not biallelic and record how many
  n_not_biallelic <- length(which(!is.biallelic(vcf)))
  
  # If the vcf is not biallelic, display a warning message
  if(n_not_biallelic > 0){
    warning("Your vcf is not all bi-allelic. Make sure to double check if this is not expected.")
  }
  
  return(long_df)
}
```


```{r load_data}
# Load the vcf  
vcf <- read.vcfR('../../data/snp_barcode/sangerBarcode_SNP_INDEL_Pf3D7_ALL_v3.combined.filtered.vqslod6.biallelic_snp.DRCongo.vcf.gz')
# Convert to long format 
df <- vcf2long(vcf)

head(df) |>
  kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

Prior to executing Moire, it is advisable to introduce a new column to identify alleles with an insufficient read count. In the following step, we apply a filter to isolate alleles with a read count below 10.
```{r filter}
df$is_missing <- df$read_count < 10
```

For the purpose of this tutorial we will subset the data to just include chromosome 1
```{r subset}
subset_df <- df[grepl('^Pf3D7_01', df$locus), ]
```

## Running the MCMC 

Now that we have the data in the correct format we will run the Markov chain Monte Carlo (MCMC) with the default parameters.

```{r mcmc, cache = TRUE}
data <- moire::load_long_form_data(subset_df)
mcmc_results <- moire::run_mcmc(data, is_missing=data$is_missing, verbose=FALSE)
```

## Summarising the results

From the MCMC results we can produce estimations for each sample and summarise the results. 

First we will look at COI using `summarize_coi`.

```{r}
# Estimate the COI for each sample
coi_summary <- moire::summarize_coi(mcmc_results)

head(coi_summary) |>
  kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

This dataframe includes summaries of both the posterior distribution of COI for each biological sample and the naive estimates.

Below we use the `summarize_he` function to summarise locus heterozygosity from the posterior distribution of sampled allele frequencies.
```{r}
he_summary <- moire::summarize_he(mcmc_results)

head(he_summary) |>
  kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

Using `summarize_allele_freqs` we can look at individual allele frequencies
```{r}
allele_freq_summary <- moire::summarize_allele_freqs(mcmc_results)

head(allele_freq_summary) |>
  kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

The `summarize_relatedness` function provides a dataframe of within-host relatedness
```{r}
relatedness_summary <- moire::summarize_relatedness(mcmc_results)

head(relatedness_summary) |>
  kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

The *moire* tool introduces a new metric called effective MOI, which adjusts for within-host relatedness. A detailed description of this metric and how to interpret it can be found [here](https://eppicenter.github.io/moire/articles/mcmc_demo.html#what-is-effective-coi).
```{r}
effective_coi_summary <- moire::summarize_effective_coi(mcmc_results)

head(effective_coi_summary) |>
  kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

```

## Summary

In summary, *moire* estimates allele frequencies, MOI, and within-host relatedness. We have shown how to generate basic results from a VCF. Moire has extensive [documentation](https://eppicenter.github.io/moire/index.html), including more details on [other functionality](https://eppicenter.github.io/moire/articles/mcmc_demo.html#estimating-allele-frequencies) available within the tool and a [tutorial](https://eppicenter.github.io/moire/articles/mcmc_demo.html#estimating-allele-frequencies) validating the outputs using simulated data.